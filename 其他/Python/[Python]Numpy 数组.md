NumPy（Numeric Python，以numpy导入）是一系列高效的、可并行的、执行高性能数值运算的函数的接口。numpy模块提供了一种新的Python数据结构——数组(array)，以及特定于该结构的函数工具箱。该模块还支持随机数、数据聚合、线性代数和傅里叶变换等非常实用的数值计算工具。

下面将学习如何创建不同形状的numpy数组，基于不同的源创建numpy数组，数组的重排和切片操作，添加数组索引，以及对某些或所有数组元素进行算术运算、逻辑运算和聚合运算。

### 1. 创建数组

numpy数组比原生的Python列表更为`紧凑`和`高效`，尤其是在多维的情况下。但与列表不同的是，数组的语法要求更为`严格`：数组必须是同构的。这意味着数组项不能混合使用不同的`数据类型`，而且不能对不同数据类型的数组项进行匹配操作。

创建numpy数组的方法很多。可以使用函数`array()`，基于类数组(array-like)数据创建数组。numpy基于数据本身推断出数组元素的类型，当然，你也可以给`array()`传递确定的`dtype`参数。numpy支持的数据类型接近二十种，例如bool_、int64、uint64、float64和<U32（针对Unicode字符串）。

备注:
```
所谓的类数组数据可以是列表、元组或另一个数组。
```

为获得较高的效率，numpy在创建一个数组时，不会将数据从源复制到新数组，而是建立起数据间的连接。也就是说，在默认情况下，numpy数组相当于是其底层数据的视图，而不是其副本。如果底层数据对象发生改变，则相应的数组数据也会随之改变。如果你不喜欢这种方式（这是默认的处理方式，除非复制的数据量过大），可以给构造函数传递`copy=True`。

备注:
```
创建数组，不会将数据从源复制到新数组，相当于是其底层数据的视图，而不是其副本。
```

实际上，Python的"列表"(list)是以数组的方式实现的，而并非列表的方式，这与"列表"(list)的字面含义并不一致。由于未使用前向指针，所以Python并没有给列表预留前向指针的存储空间。Python的大型列表只比"真正的"numpy数组多使用约13%的存储空间，但对于一些简单的内置操作，比如sum()，使用列表则要比数组快五到十倍。因此在使用numpy之前，应该问问自己是否真的需要用到某些numpy特有的功能。

我们来创建第一个数组——前10个正整数组成的简单数组：
```Python
import numpy as np

# 简单数组
numbers = np.array(range(1, 11), copy=True)
print numbers  # [ 1  2  3  4  5  6  7  8  9 10]
```

函数`ones()`、`zeros()`和`empty()`分别构造全1数组、全零数组和尚未初始化的数组。这些函数必须有数组的形状参数，该参数用一个与数组的维度相同的列表或元组来表征:
```Python
# 给定数组形状shape与数据类型type 全1数组
ones = np.ones([2, 4], dtype=np.float64)
print ones
'''
[
  [ 1.  1.  1.  1.]
  [ 1.  1.  1.  1.]
]
'''

# 给定数组形状shape与数据类型type 全0数组
zeros = np.zeros([2, 4], dtype=np.float64)
print zeros
'''
[
  [ 0.  0.  0.  0.]
  [ 0.  0.  0.  0.]
]
'''

# 给定数组形状shape与数据类型type 尚未初始化数组 其元素值不一定为零
empty = np.empty([2, 4], dtype=np.float64)
print empty
'''
[
  [ 1.  1.  1.  1.]
  [ 1.  1.  1.  1.]
]
'''
```

numpy使用数组的`ndim`、`shape`和`dtype`属性分别存储数组的维数、形状和数据类型:
```Python
# 只要没有经过变形(reshape) 该属性给出的就是数组的原始形状
print ones.shape  # (2, 4)

# 等价于len(numbers.shape)
print ones.ndim  # 2

# 数据类型
print ones.dtype  # float64
```

函数`eye(N, M=None, k=0, dtype=np.float)`用于构造一个N×M的眼形单位矩阵，其第k对角线上的值为1，其他地方的值为零。当k为正数时，对应的对角线位于主对角线上方的第k条。M为None（默认值）等价于M=N:
```Python
# N×M的眼形单位矩阵
eye = np.eye(3, k=1)
print eye
'''
[
 [ 0.  1.  0.]
 [ 0.  0.  1.]
 [ 0.  0.  0.]
]
'''
```
当需要将几个矩阵相乘时，可以使用单位矩阵作为乘法链累积器中的初始值。

除了经典的内置函数`range()`外，numpy有其独有的、更高效的生成等间隔数值数组的方式：函数`arange([start,] stop [, step,], dtype=None)`：
```Python
# 等间隔数值数组
double_numbers = np.arange(2, 5, 0.25)
print double_numbers  # [ 2.    2.25  2.5   2.75  3.    3.25  3.5   3.75  4.    4.25  4.5   4.75]
```

numpy在创建数组时记录每一项的数据类型，不过该数据类型并非不可变的。可在数组创建后，调用函数`astype(dtype, casting ="unsafe", copy=True)`来改变它。对于类型缩小的情况(将较抽象的数据类型转换为更具体的数据类型)，可能会丢失一些信息。这并非numpy特有的，任何缩小变换都可能会丢失信息:
```Python
# 改变数组数据类型
int_numbers = double_numbers.astype(np.int)
print int_numbers  # [2 2 2 2 3 3 3 3 4 4 4 4]
```

大多数numpy操作返回的是一个视图，而非原始数组的副本。为了保留原始数据，可使用`copy()`函数创建现有数组的副本。这样一来，对原始数组的任何更改都不会影响到副本。但如果数组较为庞大，比如有十亿个数组项，那就不要轻易进行复制:
```Python
# 数组的副本
double_numbers_copy = double_numbers.copy()
```

### 2. 转置和重排

借助numpy可以很容易地改变数组的形状和方向，我们再也不用像“瞎猫踫到死耗子”那样看运气了。下面我们用几个标准普尔（S&P）股票代码组成一个一维数组，然后用所有可能的方式改变它的形状：
















来源于: Python数据科学入门
