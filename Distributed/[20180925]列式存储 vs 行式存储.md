---
layout: post
author: sjf0115
title: 列式存储 vs 行式存储
date: 2018-09-25 20:39:01
tags:
  - 存储

categories: 存储
permalink: the-difference-between-row-storage-and-columnar-storage
---

### 1. 概述

磁盘仍然是在大型数据集上执行查询的主要瓶颈。即使是具有12个并行运行的磁盘的机器也无法充分利用所有核；在内存缓存数据上执行查询可以获得数十GB/s的吞吐量。IO带宽很重要。因此，如果要提高基于磁盘的查询引擎（如RDBM和Impala）的性能，最好是提高从磁盘读取的性能。如果这样做，可能意味着减少延迟（短查询中查找要读取数据的时间可能占主导地位），但大多数情况下通常意味着提高从磁盘读取的有效吞吐量。

提高磁盘带宽的传统方法是等待，以及使磁盘运转更快。但是，磁盘一般都不是很快（大约100MB/s，每台服务器大约12个磁盘）。

提高磁盘性能的另一种方法是最大化读取`有用`字节与读取总字节数的比值。我们的想法是不要读取比查询所需要的数据多，因此有用的带宽会增加，但是IO子系统的性能并不会实际提高。对于列式存储，文件格式设计的一个原则是旨在为完成基于记录数据处理的查询引擎做到这一点。

### 2. 压缩

虽然今天的内存容量允许在内存中保留大量数据，但我们仍然需要考虑对内存中的数据进行压缩。目标是以不降低性能的方式压缩数据，同时最小化从RAM到处理器的数据移动。通过使用字典将文本表示为整数，数据库对数据的压缩非常显著，从而减少数据移动，同时不会为解压缩增加CPU负载。实际上，它也可以增加性能，如下图所示。这种情况有一个简化的例子，如下图所示：

![](https://github.com/sjf0115/PubLearnNotes/blob/master/image/Other/the-difference-between-row-storage-and-columnar-storage-1.png?raw=true)

上图左侧为原始表，包含原始表示形式的文本属性（即材料和客户名称）。文本属性值存储在字典中（右上角），并为每个不同的属性值分配一个整数值。表中，文本由字典中定义的相应整数值替换。日期和时间属性也会转换为整数形式。对文本属性使用字典形式会减小表的大小，因为每个不同的属性值只能在字典中存储一次。因此，表中的每个值必须引用相应的一个整数值。

通过此方法实现的压缩因子高度依赖于压缩的数据。不同值比较少的属性压缩得比较好，但不同值比较多的属性效果不会很好。

还有其他更有效的压缩方法可以用于内存计算。但是，要使用这些方法，必须在压缩效率之间做一个权衡（这样可以在内存中提供更多数据，或者更少的数据移动（即更高性能）），解压缩所需的资源以及数据可访问性（也就是说，必须解压缩多少不相关的数据才能获得所需的数据）。字典压缩将良好的压缩效率与少解压缩资源和数据访问灵活性相结合。

### 3. 列式存储 vs 行式存储

关系型数据库以包含数据记录的表的方式组织数据。基于行和基于列的存储之间的区别在于表的存储方式。基于行的存储将表存储在一系列行中（Row-based storage stores a table in a sequence of rows）。基于列的存储将表存储在一系列列中（Column-based storage stores a table in a sequence of columns）。基于行和基于列的模型如下图所示：

![](https://github.com/sjf0115/PubLearnNotes/blob/master/image/Other/the-difference-between-row-storage-and-columnar-storage-2.png?raw=true)

两种存储模型都有其优点和缺点，如下表所示：

优缺点|行式存储|列式存储
---|---|---
优点|数据存储在一起；`INSERT`/`UPDATE`操作比较方便|查询时可以只读取涉及到的列；投影比较高效；任何列都能作为索引
缺点|`SELECT`时即使只涉及某几列，也会读取所有列的数据|`SELECT`之后，被选择的行需要根据列重新组装；`INSERT`/`UPDATE`操作比较麻烦

基于列的存储的缺点并不像看起来那么严重。在大多数情况下，我们不会处理行的所有列，尤其是在分析型查询中。此外，在分析型环境中插入或更新数据的频率一般较低。

### 4. 高效查询执行

为了展示字典压缩与列式存储结合使用的优点，下图展示了一个查询如何执行的示例。

![](https://github.com/sjf0115/PubLearnNotes/blob/master/image/Other/the-difference-between-row-storage-and-columnar-storage-3.png?raw=true)

> 图中使用到压缩章节中的数据表

查询客户为 `Miller` 并使用 `Refrigerator` 材料的所有记录。首先，去字典表里找到字符串对应数字(只进行一次字符串比较)。我们可以看到客户列中的 `Miller` 由数字4表示。材料列中的 `Refrigerator` 由数字3表示。这个过程只需要执行一次。

在第二步中，读取作为查询条件的列（即 `Customer`和 `Material` 两列，如图中的绿色标识），表中的其他列不需要考虑。然后扫描这两列来查找与查询条件匹配的值，在 `Customer` 列中所有出现的4都标记为选中，在 `Material` 列中所有出现的3都标记为选中。

这些标记可以用位图表示，可以使用布尔运算（逻辑与）将两列的位图（`Customer`，`Material`）合并为一个结果集的位图（`ResultSet`），表示整个查询条件匹配的记录。在这个示例中，我们看到只匹配到一个记录（编号为6，表示每列的第六个位置）。由于我们已经知道在每列中的位置（每列的第六个位置），因此只需要读取包含此记录数据的部分列即可。

此示例展示了压缩不仅可以降低选择过程必须读取的数据量，还可以简化选择过程，同时展示了列式存储模型还可以进一步减少选择过程所需的数据量。尽管这个示例比较简单，但它展示了字典压缩和列式存储的优点。

原文：https://www.the-paper-trail.org/post/2013-01-30-columnar-storage/

[SAP HANA on Lenovo Systems](https://lenovopress.com/sg248086.pdf)
