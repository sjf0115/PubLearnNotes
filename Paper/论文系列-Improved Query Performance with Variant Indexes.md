与并发更新为主场景相比，数据仓库这种以读为主的场景对使用更复杂索引来加速查询的需求更强烈。本文简要回顾了当前的索引技术，包括用位图 Bitmap 来表示行集，然后介绍了我们称之为位切片索引(Bit-Sliced Indexing)和投影索引(Projection Indexing)两种方法。Projection 索引将列所有值按行编号顺序物化，而 Bit-Sliced 索引是在相同数据上逐位(bit-by-bit)正交的视图。虽然这些概念最初是在 MODEL 204 产品中引入的，并在 Sybase IQ 中完全实现了 Bit-Sliced 和 Projection 索引，但这是首次在文献中对这些索引能力进行全面的考察。我们将这些变体索引类型算法与传统索引算法进行了比较。分析表明，在某些类型的 SQL 聚合、谓词求值和分组操作中，变体索引具有更好的性能优势。论文最后介绍了一种新的方法，可以非常高效地执行类似于 OLAP/Datacube  查询的多维分组查询，具有更大的灵活性。

## 1. 介绍

数据仓库是大型的、专用的数据库，包含了从多个来源整合来的数据，来支持希望分析数据趋势和异常情况的客户。分析过程通常通过执行汇总、过滤以及以多种方式对数据进行分组的查询来完成。由于查询往往很复杂，并且数据量通常非常庞大，因此在数据仓库中快速处理查询成为一种挑战。

数据仓库通常周期性地批量更新，在更新过程中无法进行查询。这意味着批量更新过程中可以重新组织索引成新的最佳聚类形式，而如果索引需要保持可用，这种方法就无法实现。由于在并发更新的情况下维护索引的问题不复存在，因此可以利用更复杂的访问结构，如专用索引或者物化聚合视图(数据仓库中称之为汇总表)来加速查询计算的速度。

本论文回顾了当前的索引技术，包括通过位图 Bitmaps 表示行集，用于加速复杂查询的计算。然后介绍了两种索引结构，我们称之为位切片索引 Bit-Sliced Indexes 和投影索引 Projection Indexes。我们的研究表明与传统的索引结构相比，位切片索引 Bit-Sliced Indexes 和投影索引 Projection Indexes 在某些类型的查询中都具有显著的性能优势。事实上，在数据仓库中，我们甚至希望在同一列上有多种类型的索引，以便可以为查询提供最佳索引。事实上，Sybase IQ 数据仓库产品目前已经提供了这两种不同的索引类型，并在某些情况下建议为同一列建立多个索引。据作者所知，本论文是数据库文献中 首次对这些索引结构进行研究并严格分析它们之间的差异。

建立数据仓库通常是为了支持在线分析处理(OLAP)。OLAP 查询性能取决于创建一组汇总表来高效的计算预期查询集。这种物化所需聚合的方法(汇总表)只有在事先知道预期查询集的情况下才有可能。具体来说，OLAP 方法处理的查询是按不同列组合(称为维度)的分组查询。这种查询在 GBLP96 中被称为 DataCube 查询。但是在即系查询(Ad-hoc)中根据不属于事先定义的维度选择条件过滤行时，因为汇总表无法提前预见这种过滤而不能使用。在这些情况下，必须通过访问基础数据上的其他索引来计算查询。

> DataCube 查询是预先物化了所需要的维度计算出汇总表直接查询，而 Ad-hoc 查询因无法提前预知查询的维度而不能使用这种方式。

例 1.1：假设我们有一个星形连接范式，由包含销售数据的中心事实表 Sales、维度表 Stores (销售地点)、Time (销售时间)、Product (销售时间) 以及 Promotion(正在使用的促销方式)组成。通过使用预先计算的汇总表，OLAP 产品能够快速回答一些问题，例如在过去4周内东海岸某商店的某品牌产品在降价促销活动中的总销售额。对汇总表进行 "切片和切块"的维度会导致多维交叉计算（Datacube）中的部分或全部可以预先计算，并以汇总表的形式存储，以提高效率。但是，如果我们想执行某些没有预先计算的检索条件，例如，除了温度达到90度的日子的销售量外，其他条件与上一个问题一样，如果汇总表中不存基于温度的维度，就无法快速提供答案。而且，汇总表中可预计算的维度数量也是有限的，因为必须预计算这些维度的所有组合，才能在运行时获得良好的性能。这表明，需要丰富选择条件的查询必须通过访问基础数据而不是预计算汇总表来进行计算。

> 指出 DataCube 查询的缺点

第5节提出了一个算法可以高效计算具有此类丰富选择条件的 OLAP 风格的查询。

论文概要：我们在第2节中定义了值列表索引 Value-List Indexes、投影索引 Projection Indexes 和位切片索引 Bit-Sliced Indexes 以及它们在查询处理中的应用。第3节介绍了使用第2节介绍的索引类型来评估聚合函数的算法。在第4节中提出了评估 Where 子句条件的算法，特别是范围谓词。在第5节中，我们引入了一种索引方法，通过该方法可以高效的执行允许非维度选择条件的 OLAP 风格查询。该方法结合了位图索引和物理行聚类这两种特性，这两种特性为 OLAP 风格查询提供了重要优势。第6节给出了我们的结论。

## 2. 索引定义

在本节中，我们将研究传统的值列表索引，并介绍如何轻松采用位图表示法来存储 RID 列表。然后，我们将介绍位切片索引 Bit-Sliced Indexes 和投影索引 Projection Indexes。

### 2.1 传统的值列表索引

目前，大多数数据库系统提供的数据库索引都使用 B 树结构来检索表中指定值的记录，通常涉及一个或多个索引列。B 树索引的叶子结点层由索引键值的条目序列组成。每个键值反映了表中一个或多行中被索引列的值，每个键值条目指向了具有该值的行集。由于在关系型数据库中，索引表的所有行都会在 B 树中被精确引用一次，并按键值进行分区，因此这种类型的索引也可称为值分区索引。但是，对象关系数据库允许多值属性，因此同一行将来可能会出现在索引中的多个键值下。因此，我们将这类索引简称为值列表 Value-List 索引。

> 在数据库文档中，B+树通常简称为 B 树，我们也遵循这一习惯。

在键值代表多个列值的情况下，列值的连接方式是可以从连接表中检索到所涉及的各个列的值。因此，在列的连接中，`LNAME||FNAME`，可以将 `LNAME='ABC'` 和 `FNAME='DEFG'` 这一对与 `LNAME='ABCD'` 和 `FNAME='EFG'` 这一对区分开来。

传统上，值列表（B树）索引以 RID（行ID）单独引用每一行，指定该行的磁盘位置。B 树中每个不同的键值条目都包含一个 RID 序列，即 RID 列表。在键值数量相对于行数量较少的索引中，大多数键值都会有大量相关联的 RID，因此在我们称之为 RID 列表片段（包含具有该键值的行的冗长 RID 列表）的头部列出一次键值，就有可能实现压缩。例如，MVS DB2 就提供了这种压缩方式，它为一个最多包含 255 个4字节 RID 的片段依次列出一个键值。关联行超过 255 行的键值需要多个这样的片段，而有些 RID 列表太长，无法一次性在内存中实现。在下文中，我们假设 RID 列表（以及随后的位图）是以多个 Fragments 的形式从磁盘读取的。在多个4字节 RID 中分摊键值空间后，B 树索引叶子层的字节长度可以近似为表中行数的 4 倍，叶子节点平均满度的倒数。在下文中，我们将假设所处理的数据更新频率很低，因此 B 树叶页可以被完全填满，并在批量更新时进行重组。因此，具有少量键值的 B 树索引叶级的字节长度可以近似为表中记录数的 4 倍。

#### 2.1.1 位图索引

位图索引最初是为美国计算机公司（Computer Corporation of America）的 Model 204 产品中数据库使用而开发的。位图是在值列表 Value-List 索引中表示 RID 列表的另一种形式。当索引的键值数量较少时，位图比 RID 列表具有更高的空间效率。此外，我们还会证明，对于很多函数来说，位图通常也更更节省 CPU，因为它的表示形式非常简单。要为表 `T = {r1, r2, ... rn}` 的 n 行创建位图，我们首先要从表 T 的行到 `Z[M]` 的 1-1 映射 m 开始。在接下来的内容中，我们避免频繁提到映射 m。当我们说到 `m(r)` 时，我们指是表 T 中某一行 r 的行号。

请注意，尽管在 `T={r1,r2,...rn}` 中有 n 行，但最大行号 M 并不一定与 n 相同，这是因为通常使用一种方法是将固定的记录数 p 与每个磁盘页关联起来，以便快速查找。因此，对于行号 j 的给定行 r 来说，为检索行 r 而应访问的磁盘页码为 `j/p`，页内偏移量是 `j%p`。这意味着行将按照磁盘上聚集的顺序被分配行号，这是一个很有价值的特性。由于行的大小可能不固定，我们不一定能在每个磁盘页上获取相同数量的行，因此必须选择最大值 p，因此 `Z[M]` 中的一些整数可能会被浪费。因为它们不在表 T 中任何行 r 的映射 m 范围内；相反，它们将对应于无法容纳全部 p 行的页面上不存在的空位。（我们可能会发现对于 `Z[M]` 中的一些行号 j 来说，$$m^{-1}{j}$$ 是未定义的。）

一个"位图" B 是在 T 上定义的一个由M位组成的序列。如果位图 B 旨在列出具有给定属性 P 的 T 中的行，那么对于每一个具有属性 P 并且行号为 j 的行 r，我们将 B 中的第 j 位设置为一；所有其他位都设置为零。针对具有值v1,v2,...,vk的列C的位图索引是一个B树，其条目有这些键值，并且关联的数据部分包含具有属性C = v1,...,C = vk的位图。因此，这个索引中的位图只是指定特定列值的RID列表的一种新方法。见图2.1的例子。注意，“部门 = '体育'”的条目是由一系列连续的位图片段组成的。


我们说，如果位图中一位的比例很大，那么位图是密集的。对于一个列有32个值的位图索引，其位图的平均密度将是1/32。在这种情况下，持有一个位图列索引的磁盘空间将与需要的行标识符列表（RID-list）索引的磁盘空间相当（每个存在的RID大约需要32位）。虽然未压缩的位图索引大小与列值的数量成正比，但行标识符列表（RID-list）索引的大小对于任何数量的值来说大致相同（只要我们可以继续用一长块RID摊销键值的大小）。对于值数量非常少的列索引，位图将具有很高的密度（例如，对于谓词如性别='男'或性别='女'，密度可能为50％），节省的磁盘空间是巨大的。另一方面，当位图索引的平均位图密度变得太低时，存在用于压缩位图的方法。其中最简单的一种是将位图转回行标识符列表，我们将在以下内容中假设这种情况。

#### 2.1.2 Bitmap Index Performance

数据库查询性能的一个重要考虑因素是，布尔操作(如 AND、OR 和 NOT)对于位图来说非常快。给定位图 B1 和 B2，我们可以计算出一个新的位图 B3, `B3 = B1 AND B2`，通过将所有位图视为长整型数组并循环遍历它们，使用 `&` 操作生成 C：
```sql
for (i = 0; i < len(B1); i++)
 /* Note: len(B1)=len(B2)=len(B3)*/
 B3[i] = B1[i] & B2[i];
 /*B3 = B1 AND B2 */
```

我们通常不会期望整个位图驻留在内存中，但会执行一个循环来操作位图，通过从磁盘中以长片段的形式读取它们。我们忽略这个循环。使用类似的方法，我们可以计算 `B3 = B1 OR B2`。但是计算 `B3 = NOT(B1)` 需要一个额外的步骤。由于一些 Bit 位可以对应不存在的行，我们假设存在 `Existence Bitmap` (可以称为 `EBM` )正好有对应于现有行的那 1 位。现在，当我们在位图 B 上执行 NOT 操作时，我们循环通过执行C的~操作的长整型数组，然后将结果与EBM中相应的长整型数组进行AND运算

```sql
for (i = 0; i < len(B1); i++)
 B3[i] = ~B1[i] & EBM[i];
 /* B3 = NOT(B1) for rows that exist */
```

典型的 Select 语句可能在它们的 Where 子句中有许多谓词，必须以布尔方式结合。然后被检索或汇总在Select目标列表中的行集合，在以下内容中称为Foundset（找到的集合）。有时，由Where子句过滤出的行必须进一步分组，因为有group-by子句，我们将限制在单个组内的行集合称为Groupset（分组集合）。

最后，我们展示了如何高效地执行一个Foundset的位图的COUNT函数。首先，声明了一个短整型数组shcount[]，其条目初始化为包含条目下标中设置为一的位数。有了这个数组，我们可以通过一个位图作为短整型值的数组循环，如算法2.1所示可以获得总位图的计数。很明显，shcount[]数组用于提供并行性，一次计算COUNT在许多位上。

```sql
/* Assume B1[ ] is a short int array overlaying a Foundset Bitmap */

count = 0;
for(i=0;i<SHNUM;i++)
 count += shcount[B1[i]];

/* add count of bits for next short int*/
```

#### 2.1.3 Segmentation


与 RID 列表上的循环操作相比，位图 AND、OR、NOT 或 COUNT 的循环操作非常快，在 RID 列表上，每个 RID 需要几个操作，只要涉及的位图具有相当高的密度(低至约1%)。

为了优化位图索引的访问，可以将位图分割成大小相等的片段，以适应单个固定大小的磁盘页面。对应于这些片段，表的行被划分成段，每个段有相同数量的行槽位。在MODEL 204中（见[M204, O'NEI87]），一个位图片段适合放在一个6 KB的页面上，并包含大约48K位，因此表被分割成每个大约有48K行的段。这种分段有两个重要的含义。

第一个含义涉及到行标识符列表（RID-lists）。当位图足够稀疏以至于需要转换成行标识符列表时，一个段的行标识符列表保证适合在一个磁盘页面上（48K的1/32大约是1.5K；MODEL 204实际上允许比1/32还要稀疏的位图，所以几个行标识符列表可能适合在单个磁盘页面上）。此外，行标识符只需要是两个字节长，因为它们只指定段内的行位置（一个段的48K行可以用一个短整型计数）。在每个行标识符列表的开头，段号将指定一个较长行标识符（4字节或更多）的高阶位，但是相对于段的行标识符只使用两个字节。这是一种重要的前缀行标识符压缩形式，它极大地加快了索引范围搜索。

分段的第二个含义涉及到组合谓词。在MODEL 204中，特定值的B树索引条目由许多指针组成，这些指针按段指向位图或行标识符列表片段，但没有指向没有代表性行的段的指针。例如，在一个聚集索引的情况下，每个特定的索引值条目将只有指向少数几个段的指针。现在，如果涉及不同列索引的几个谓词被逻辑与（AND）连接起来，评估就会逐段进行。如果其中一个谓词索引对某个段没有指向位图片段的指针，那么其他索引的段片段也可以被忽略。像这样的查询可能在负载中非常常见，通过忽略这些索引片段的I/O所节省的I/O可以显著提高性能。

位图表示和行标识符列表表示是可以互换的：两者都提供了一种列出所有具有给定索引值或值范围的行的方法。简单地说，当涉及的位图表示相对密集时，位图在存储使用和布尔操作的效率上都比行标识符列表更加高效。实际上，一个位图索引可以包含某些条目值的行标识符列表，或者甚至是值条目内某些段的行标识符列表，只要在该段中具有给定键值的行数量太稀疏，使用位图就不会有效率。在接下来的内容中，我们将假设一个Bitmapped索引根据需要结合位图和行标识符列表表示，并继续将这种混合形式称为值列表索引。当我们提到索引中给定值v的位图时，这应该被理解为一个通用名称：它可能是一个位图，也可能是一个行标识符列表，或者是这两种形式的逐段组合。

### 2.2 Projection Indexes

假设 C 是表 T 的一个列，那么 C 上的投影索引是由 C 列值的存储序列组成，根据提取值在 T 标中的行号进行排序。（对于未使用的行号可能存在空缺。）如果 C 列的长度是4字节，那么我们可以在每个 4KB 大小的磁盘页上放置来自 C 的 1000 个值（假设没有空缺），并继续为连续的列值做这样的操作，直到我们构建出投影索引。现在对于表中给定的行号 n = m(r)，我们可以访问正确的磁盘页 p 和槽位 s，可以通过一个简单的公式来检索相应的 C 值：·`p = n/1000` 且 `s = n%1000`。此外，给定投影索引中某位置的 C 值，我们可以轻松地计算出行号：`n = 1000*p + s`。

如果 C 列的值是可变长度而不是固定长度，有两种选择。我们可以设置一个最大大小，并在每个页面上放置固定数量的列值，如之前所述，或者我们可以使用 B-树结构来通过查找行号 n 来访问列值 C。可变长度值的情况显然比固定长度的效率低一些，我们在接下来的内容中将假设固定长度的 C 值。

在某些情况下，投影索引在必须为 Foundset 的所有行检索列值时非常高效。例如，如果 Foundset 的密度为1/50（没有聚集，因此密度在所有表段中均匀分布），并且列值的长度如上文所述为4字节，则1000个值将适合在一个4 KByte页上，我们预计每个投影索引页能提取20个值。相比之下，如果检索表的行，则假设每行200字节，只有20行将适合在一个4 KByte页上，我们预计每页只能提取1行。因此，从投影索引读取值只需要1/20的磁盘页访问数量，而从行中读取值。Sybase IQ 产品是第一个大量使用投影索引的产品，以“快速投影索引”（Fast Projection Index）[EDEL95, FREN95]的名称为人所熟知。

投影索引的定义让人联想到垂直分割表的列。在大多数 Select 语句检索少量列的工作负载下，垂直分割是一个好策略，但当大多数查询检索很多列时，这是一个坏主意。TPC-D 基准测试实际上禁止了垂直分区，可能是基于这样的理论：选择的查询尚未足以调整以惩罚这种策略。但是投影索引和垂直划分不同。我们假设表的行仍以连续形式存储（这是TPC-D的要求），而投影索引是辅助的检索效率。当然这意味着列值将在索引中被复制，但实际上所有传统索引在这个意义上都复制了列值。

### 2.3 Bit-Sliced Indexes

位切片索引储存了一组 '位图 Bitmap 切片'，这些切片与投影索引中保存的数据是“正交”的。正如我们将要看到的，它们为计算Foundsets（找到的行集）的聚合提供了一种高效的手段。我们以一个例子开始我们对位切片索引的定义。

例 2.2：考虑一个命名为SALES的表，其中包含了过去一个月内属于某大连锁店的各个店铺所进行的所有销售的行。SALES表有一个名为dollar_sales的列，它代表了每行销售的美元金额。

现在将dollar_sales列解释为代表便士的整数，表示为N+1位的二进制数。我们定义一个函数D(n,i)，i=0,...,N，对于SALES中的行号n来有非零值，dollar_sales为0，除了行dollar_sales有非空值的情况下，D(n,i)的值定义如下：

D(n,0) = 1 如果行号n的dollar_sales中的1位是开的
D(n,1) = 1 如果行号n的dollar_sales中的2位是开的
...
D(n,i) = 1 如果行号n的dollar_sales中的2的i次幂位是开的

现在对于每个值i，i=0到N，使得对于SALES中的某些行，D(n,i) > 0，我们在SALES表上定义位图B，使得

位图B的第n位被设置为D(n,i)。请注意，通过要求对于SALES中的某些行，D(n,i) > 0，我们保证了我们不必表示所有为零的位图。对于像SALES这样的真实表，具有非零位的适合位图集在创建索引时很容易确定。◊

例 2.1 的定义可以推广到任何表 T 中的列 C，其中列 C 被解释为从最不重要的位（i=0）到最重要的位（i=N）的一系列位。

定义 2.1：位切片索引。表 T 上的列 C 的位切片索引是所有定义的位图B的集合

类似于例 2.2 中dollar_sales。由于 C 列中的空值不会有任何位设置为 1，很明显，

只有非空值的行才会以1位出现在这些位图中。每个单独的位图B被称为列的一个位切片。我们还定义位切片索引有一个位图

表示具有列中非空值的行集合，代表具有空值的行集合。
显然，B可以从B和存在位图

EBM，但我们希望在下面的算法中节省这个努力。事实上，位图B和B是如此有用，我们假设从

现在起，B是值列表位图索引的一部分（显然B
已经存在，因为null是一个特定的值）。◊

在接下来的算法中，我们通常假设

列 C 是数值型的，要么是整数，要么是浮点值。在使用位切片索引时，不同的值在它们的二进制表示法中要有匹配的小数点。取决于浮点数的大小变化，这可能会导致在值相差许多数量级的情况下有异常大量的切片。然而，这种情况在商业应用中不太可能发生。

一些MODEL 204的客户使用了自定义方法来位切片聚合量，并在[O'NEI87]第48页上定义。Sybase IQ目前提供了一个完全实现的位切片索引，对查询优化器是已知的，并对SQL用户是透明的。通常


## 3. Comparing Index types for Aggregate Evaluation
