迟到数据的处理

有了事件时间、水位线和窗口的相关知识，现在就可以系统性地讨论一下怎样处理迟到数
据了。我们知道，所谓的“迟到数据”（late data），是指某个水位线之后到来的数据，它的时
间戳其实是在水位线之前的。所以只有在事件时间语义下，讨论迟到数据的处理才是有意义的。
事件时间里用来表示时钟进展的就是水位线（watermark）。对于乱序流，水位线本身就可
以设置一个延迟时间；而做窗口计算时，我们又可以设置窗口的允许延迟时间；另外窗口还有
将迟到数据输出到测输出流的用法。所有的这些方法，它们之间有什么关系，我们又该怎样合
理利用呢？这一节我们就来讨论这个问题。
176
6.4.1 设置水位线延迟时间


6.4.2 允许窗口处理迟到数据
水位线延迟设置的比较小，那之后如果仍有数据迟到该怎么办？对于窗口计算而言，如果
水位线已经到了窗口结束时间，默认窗口就会关闭，那么之后再来的数据就要被丢弃了。
自然想到，Flink 的窗口也是可以设置延迟时间，允许继续处理迟到数据的。
这种情况下，由于大部分乱序数据已经被水位线的延迟等到了，所以往往迟到的数据不会
太多。这样，我们会在水位线到达窗口结束时间时，先快速地输出一个近似正确的计算结果；
然后保持窗口继续等到延迟数据，每来一条数据，窗口就会再次计算，并将更新后的结果输出。
这样就可以逐步修正计算结果，最终得到准确的统计值了。

类比班车的例子，我们可以这样理解：大多数人是在发车时刻前后到达的，所以我们只要
把表调慢，稍微等一会儿，绝大部分人就都上车了，这个把表调慢的时间就是水位线的延迟；
到点之后，班车就准时出发了，不过可能还有该来的人没赶上。于是我们就先慢慢往前开，这
段时间内，如果迟到的人抓点紧还是可以追上的；如果有人追上来了，就停车开门让他上来，
然后车继续向前开。当然我们的车不能一直慢慢开，需要有一个时间限制，这就是窗口的允许
延迟时间。一旦超过了这个时间，班车就不再停留，开上高速疾驰而去了。
所以我们将水位线的延迟和窗口的允许延迟数据结合起来，最后的效果就是先快速实时地
输出一个近似的结果，而后再不断调整，最终得到正确的计算结果。回想流处理的发展过程，
这不就是著名的 Lambda 架构吗？原先需要两套独立的系统来同时保证实时性和结果的最终
正确性，如今 Flink 一套系统就全部搞定了。
177

6.4.3 将迟到数据放入窗口侧输出流

即使我们有了前面的双重保证，可窗口不能一直等下去，最后总要真正关闭。窗口一旦关
闭，后续的数据就都要被丢弃了。那如果真的还有漏网之鱼又该怎么办呢？
那就要用到最后一招了：用窗口的侧输出流来收集关窗以后的迟到数据。这种方式是最后
“兜底”的方法，只能保证数据不丢失；因为窗口已经真正关闭，所以是无法基于之前窗口的
结果直接做更新的。我们只能将之前的窗口计算结果保存下来，然后获取侧输出流中的迟到数
据，判断数据所属的窗口，手动对结果进行合并更新。尽管有些烦琐，实时性也不够强，但能
够保证最终结果一定是正确的。
如果还用赶班车来类比，那就是车已经上高速开走了，这班车是肯定赶不上了。不过我们
还留下了行进路线和联系方式，迟到的人如果想办法辗转到了目的地，还是可以和大部队会合
的。最终，所有该到的人都会在目的地出现。
所以总结起来，Flink 处理迟到数据，对于结果的正确性有三重保障：水位线的延迟，窗
口允许迟到数据，以及将迟到数据放入窗口侧输出流。我们可以回忆一下之前 6.3.5 小节统计
每个 url 浏览次数的代码 UrlViewCountExample，稍作改进，增加处理迟到数据的功能。具体
代码如下。
