与并发更新为主场景相比，数据仓库这种以读为主的场景对使用更复杂索引来加速查询的需求更强烈。本文简要回顾了当前的索引技术，包括用位图 Bitmap 来表示行集，然后介绍了我们称之为位切片索引(Bit-Sliced Indexing)和投影索引(Projection Indexing)两种方法。Projection 索引将列所有值按行编号顺序物化，而 Bit-Sliced 索引是在相同数据上逐位(bit-by-bit)正交的视图。虽然这些概念最初是在 MODEL 204 产品中引入的，并在 Sybase IQ 中完全实现了 Bit-Sliced 和 Projection 索引，但这是首次在文献中对这些索引能力进行全面的考察。我们将这些变体索引类型算法与传统索引算法进行了比较。分析表明，在某些类型的 SQL 聚合、谓词求值和分组操作中，变体索引具有更好的性能优势。论文最后介绍了一种新的方法，可以非常高效地执行类似于 OLAP/Datacube  查询的多维分组查询，具有更大的灵活性。

## 1. 介绍

数据仓库是大型的、专用的数据库，包含了从多个来源整合来的数据，来支持希望分析数据趋势和异常情况的客户。分析过程通常通过执行汇总、过滤以及以多种方式对数据进行分组的查询来完成。由于查询往往很复杂，并且数据量通常非常庞大，因此在数据仓库中快速处理查询成为一种挑战。

数据仓库通常周期性地批量更新，在更新过程中无法进行查询。这意味着批量更新过程中可以重新组织索引成新的最佳聚类形式，而如果索引需要保持可用，这种方法就无法实现。由于在并发更新的情况下维护索引的问题不复存在，因此可以利用更复杂的访问结构，如专用索引或者物化聚合视图(数据仓库中称之为汇总表)来加速查询计算的速度。

本论文回顾了当前的索引技术，包括通过位图 Bitmaps 表示行集，用于加速复杂查询的计算。然后介绍了两种索引结构，我们称之为位切片索引 Bit-Sliced Indexes 和投影索引 Projection Indexes。我们的研究表明与传统的索引结构相比，位切片索引 Bit-Sliced Indexes 和投影索引 Projection Indexes 在某些类型的查询中都具有显著的性能优势。事实上，在数据仓库中，我们甚至希望在同一列上有多种类型的索引，以便可以为查询提供最佳索引。事实上，Sybase IQ 数据仓库产品目前已经提供了这两种不同的索引类型，并在某些情况下建议为同一列建立多个索引。据作者所知，本论文是数据库文献中 首次对这些索引结构进行研究并严格分析它们之间的差异。

建立数据仓库通常是为了支持在线分析处理(OLAP)。OLAP 查询性能取决于创建一组汇总表来高效的计算预期查询集。这种物化所需聚合的方法(汇总表)只有在事先知道预期查询集的情况下才有可能。具体来说，OLAP 方法处理的查询是按不同列组合(称为维度)的分组查询。这种查询在 GBLP96 中被称为 DataCube 查询。但是在即系查询(Ad-hoc)中根据不属于事先定义的维度选择条件过滤行时，因为汇总表无法提前预见这种过滤而不能使用。在这些情况下，必须通过访问基础数据上的其他索引来计算查询。

> DataCube 查询是预先物化了所需要的维度计算出汇总表直接查询，而 Ad-hoc 查询因无法提前预知查询的维度而不能使用这种方式。

例 1.1：假设我们有一个星形连接范式，由包含销售数据的中心事实表 Sales、维度表 Stores (销售地点)、Time (销售时间)、Product (销售时间) 以及 Promotion(正在使用的促销方式)组成。通过使用预先计算的汇总表，OLAP 产品能够快速回答一些问题，例如在过去4周内东海岸某商店的某品牌产品在降价促销活动中的总销售额。对汇总表进行 "切片和切块"的维度会导致多维交叉计算（Datacube）中的部分或全部可以预先计算，并以汇总表的形式存储，以提高效率。但是，如果我们想执行某些没有预先计算的检索条件，例如，除了温度达到90度的日子的销售量外，其他条件与上一个问题一样，如果汇总表中不存基于温度的维度，就无法快速提供答案。而且，汇总表中可预计算的维度数量也是有限的，因为必须预计算这些维度的所有组合，才能在运行时获得良好的性能。这表明，需要丰富选择条件的查询必须通过访问基础数据而不是预计算汇总表来进行计算。

> 指出 DataCube 查询的缺点

第5节提出了一个算法可以高效计算具有此类丰富选择条件的 OLAP 风格的查询。

论文概要：我们在第2节中定义了值列表索引 Value-List Indexes、投影索引 Projection Indexes 和位切片索引 Bit-Sliced Indexes 以及它们在查询处理中的应用。第3节介绍了使用第2节介绍的索引类型来评估聚合函数的算法。在第4节中提出了评估 Where 子句条件的算法，特别是范围谓词。在第5节中，我们引入了一种索引方法，通过该方法可以高效的执行允许非维度选择条件的 OLAP 风格查询。该方法结合了位图索引和物理行聚类这两种特性，这两种特性为 OLAP 风格查询提供了重要优势。第6节给出了我们的结论。

## 2. 索引定义

在本节中，我们将研究传统的值列表索引，并介绍如何轻松采用位图表示法来存储 RID 列表。然后，我们将介绍位切片索引 Bit-Sliced Indexes 和投影索引 Projection Indexes。

### 2.1 传统的值列表索引

目前，大多数数据库系统提供的数据库索引都使用 B 树结构来检索表中指定值的记录，通常涉及一个或多个索引列。B 树索引的叶子结点层由索引键值的条目序列组成。每个键值反映了表中一个或多行中被索引列的值，每个键值条目指向了具有该值的行集。由于在关系型数据库中，索引表的所有行都会在 B 树中被精确引用一次，并按键值进行分区，因此这种类型的索引也可称为值分区索引。但是，对象关系数据库允许多值属性，因此同一行将来可能会出现在索引中的多个键值下。因此，我们将这类索引简称为值列表 Value-List 索引。

> 在数据库文档中，B+树通常简称为 B 树，我们也遵循这一习惯。

在键值代表多个列值的情况下，列值的连接方式是可以从连接表中检索到所涉及的各个列的值。因此，在列的连接中，`LNAME||FNAME`，可以将 `LNAME='ABC'` 和 `FNAME='DEFG'` 这一对与 `LNAME='ABCD'` 和 `FNAME='EFG'` 这一对区分开来。

传统上，值列表（B树）索引以 RID（行ID）单独引用每一行，指定该行的磁盘位置。B 树中每个不同的键值条目都包含一个 RID 序列，即 RID 列表。在键值数量相对于行数量较少的索引中，大多数键值都会有大量相关联的 RID，因此在我们称之为 RID 列表片段（包含具有该键值的行的冗长 RID 列表）的头部列出一次键值，就有可能实现压缩。例如，MVS DB2 就提供了这种压缩方式，它为一个最多包含 255 个4字节 RID 的片段依次列出一个键值。关联行超过 255 行的键值需要多个这样的片段，而有些 RID 列表太长，无法一次性在内存中实现。在下文中，我们假设 RID 列表（以及随后的位图）是以多个 Fragments 的形式从磁盘读取的。在多个4字节 RID 中分摊键值空间后，B 树索引叶子层的字节长度可以近似为表中行数的 4 倍，叶子节点平均满度的倒数。在下文中，我们将假设所处理的数据更新频率很低，因此 B 树叶页可以被完全填满，并在批量更新时进行重组。因此，具有少量键值的 B 树索引叶级的字节长度可以近似为表中记录数的 4 倍。

#### 2.1.1 位图索引

位图索引最初是为美国计算机公司（Computer Corporation of America）的 Model 204 产品中数据库使用而开发的。位图是在值列表 Value-List 索引中表示 RID 列表的另一种形式。当索引的键值数量较少时，位图比 RID 列表具有更高的空间效率。此外，我们还会证明，对于很多函数来说，位图通常也更更节省 CPU，因为它的表示形式非常简单。要为表 `T = {r1, r2, ... rn}` 的 n 行创建位图，我们首先要从表 T 的行到 `Z[M]` 的 1-1 映射 m 开始。在接下来的内容中，我们避免频繁提到映射 m。当我们说到 `m(r)` 时，我们指是表 T 中某一行 r 的行号。

请注意，尽管在 `T={r1,r2,...rn}` 中有 n 行，但最大行号 M 并不一定与 n 相同，这是因为通常使用一种方法是将固定的记录数 p 与每个磁盘页关联起来，以便快速查找。因此，对于行号 j 的给定行 r 来说，为检索行 r 而应访问的磁盘页码为 `j/p`，页内偏移量是 `j%p`。这意味着行将按照磁盘上聚集的顺序被分配行号，这是一个很有价值的特性。由于行的大小可能不固定，我们不一定能在每个磁盘页上获取相同数量的行，因此必须选择最大值 p，因此 `Z[M]` 中的一些整数可能会被浪费。因为它们不在表 T 中任何行 r 的映射 m 范围内；相反，它们将对应于无法容纳全部 p 行的页面上不存在的空位。（我们可能会发现对于 `Z[M]` 中的一些行号 j 来说，$$m^{-1}{j}$$ 是未定义的。）

"位图" B 是在表 T 上定义的一个由 M 个 bit 位组成的序列。如果位图 B 目的是列出表 T 中具有给定属性 P 的行，那么对于具有属性 P 并且行号为 j 的行 r，我们将 B 中的第 j 位设置为 1，所有其他位都设置为 0。针对具有值 v1,v2,...,vk 的列 C，其位图索引是一个 B 树，其条目具有这些键值和相关的数据部分，这些数据部分包含具有属性 C = v1,...,C = vk 的位图。因此，该索引中的位图只是指定特定列值的 RID 列表的一种新方法，见图 2.1 的例子。注意，由一系列连续的位图片段组成了 `部门 = '体育'` 的条目。

如果位图中 bit 1 占所有 bit 的比例很大，那么我们说位图是密集的。对于一个列有 32 个值的位图索引，那么位图的平均密度将是 3.125%，这意味着 32 位中约有一位被设置为 1。在这种情况下，包含位图列索引的位图所需要的磁盘空间将与 RID 列表索引(每个 RID 大约 32 位)所需要磁盘空间相当。虽然未压缩的位图索引大小与列值的数量成正比，但 RID 列表索引的大小对于任何数量的值来说大致相同（只要值的数量远小于行的数量，这样我们就可以继续用长的 RID 块来分摊键的大小）。对于值数量非常少的列索引，位图将具有很高的密度（例如，性别='男'或性别='女'，密度可能为50％），这样可以大量的磁盘空间。另一方面，当位图索引的平均位图密度太低时，也有压缩位图的方法。其中最简单的一种是将位图转回 RID 列表，我们将在下文中假设这种方法。

![](1)

#### 2.1.2 Bitmap Index Performance

数据库查询性能的一个重要考虑因素是，布尔操作(如 AND、OR 和 NOT)对于位图来说非常快。给定位图 B1 和 B2，我们可以计算出一个新的位图 B3 (`B3 = B1 AND B2`)，通过将所有位图视为长整型数组并使用 `&` 操作来循环遍历它们：
```sql
for (i = 0; i < len(B1); i++)
 /* Note: len(B1)=len(B2)=len(B3)*/
 B3[i] = B1[i] & B2[i];
 /*B3 = B1 AND B2 */
```

我们通常不会期望整个位图都驻留在内存中，而是会执行一个循环，通过从磁盘中以长片段的形式来操作位图。在下文中，我们忽略这个循环。使用类似的方法，我们可以计算 `B3 = B1 OR B2`。但是计算 `B3 = NOT(B1)` 需要一个额外的步骤。由于一些 Bit 位可能对应不存在的行，因此我们假设一个 `Existence Bitmap` (可以称为 `EBM` )位图中的 bit 1 正好对应现有行。现在，当我们在位图 B 上执行 NOT 操作时，我们通过循环长整型数组并执行 `~` 操作，然后将结果与 EBM 中相应的长整型进行 AND 运算：
```sql
for (i = 0; i < len(B1); i++)
 B3[i] = ~B1[i] & EBM[i];
 /* B3 = NOT(B1) for rows that exist */
```

Select 语句中的 Where 子句可能包含多个谓词，这些谓词必须以布尔方式进行组合。然后在 Select 目标列表中检索或汇总生成记录集，在下文中称为 Foundset。有时，由于使用了 `Group By ` 子句，由 Where 子句过滤出的行必须进一步分组，我们将限制在单个分组内的行集合称为 Groupset。

最后，我们展示了如何高效地执行一个 Foundset 的位图的 COUNT 函数。首先，声明了一个短整型数组 `shcount[]`，初始化为下标 i 中 bit 1 的位数：
```sql
#define SHNUM 65536 /* the number of distinct short ints */
short int shcount[SHNUM]; /*one for each short int subscript */
/* Assume now that the function with prototype: int fcount(short int) returns a count of the number of 1-bits in its short int argument */
for(i = 0; i < SHNUM;i++)
  shcount[i] = fcount(i);
  /*shcount[i] is count of bits in subscript */
```
有了这个数组，我们可以以短整型数组的形式循环遍历位图，从而得到整个位图的计数，如算法 2.1 所示。很明显，使用 `shcount[]` 数组是为了提高计算 COUNT 的多位并行效率。如果使用场整数下标数组，则会占用过多内存。`shcount[]` 数组声明为 char 类型，因为短整型下标中的 bit 计数可以容纳一个 char 中，如果 `char shcount[]` 数组可以缓存，尽管需要额外的循环，但这可能是更好的选择。
```sql
/* Assume B1[ ] is a short int array overlaying a Foundset Bitmap */

count = 0;
for(i = 0; i < SHNUM; i++)
 count += shcount[B1[i]];
/* add count of bits for next short int*/
```
与 RID 列表上的相同操作相比，计算位图 Bitmap AND、OR、NOT 或 COUNT 的循环速度非常快，因为在 RID 列表上每个 RID 都需要进行多次操作，只要涉及的位图具有相当高的密度(可能低至1%或更低)。

例 2.1。在 O'NEI91 的 Set Query 基准测试中，查询套件 Q5 中的一条 SQL 语句的测量结果很好地说明了位图性能。在一个名为 BENCH 的 1,000,000 行的表中，名为 K10 和 K25 的两列的基数分别为 10 和 25，表中的所有行都同样有可能为其中任何一列取有效值。因此，该列上索引的位图密度分别为 10% 和 4%。Q5 套件中的一个 SQL 语句是:
```sql
SELECT K10, K25, COUNT(*)
FROM BENCH
GROUP BY K10, K25;
```
1995 年在一台 66 MHz Power PC 对 Praxis Omni Warehouse (MODEL 204的C语言版本)进行的基准测试表明，执行此查询所需的时间仅为 19.25 秒。所采用的方法是从 K10 和 K25 的所有值的索引中读取位图 bitmap，对所有 250 对值执行双循环，并对所有位图对 AND，并对结果进行 COUNT 计数。因此，在相对较弱的处理器上，1,000,000 位图的 250 个 AND 和 250 个 COUNT 只需 19.25 秒。相比之下，在 IBM 9221 型号 170 大型机上运行的 MVS DB2 Version 2.3 使用了一种算法，该算法从行中提取并写出所有(K10, K25)值对，按值对排序，并按组计算结果，耗时 248 秒，CPU 耗时223秒。

#### 2.1.3 Segmentation

为了优化位图索引访问，位图通常被分割成大小相等的片段，这些片段适合单个固定大小的磁盘页。与这些片段相对应，表的行被划分为若干段，每个段都具有相同数量的序号行，对应于位图片段。例如，在 MODEL 204 中，一个位图片段预计适合 6 KB 的磁盘页，并包含约 48K 比特位。因此，表被分成每段大约 48K 行的段。这种分割有两个重要影响。

第一个影响涉及到 RID 列表。当位图足够稀疏以至于需要转换成 RID 列表时，一个段的 RID 列表可以保证在一个磁盘页上放的下（48K 的 1/32 大约是 1.5K；MODEL 204 实际上允许比这还要稀疏的位图，因此不同段甚至不同索引值的多个 RID 列表可以在一个磁盘页上放的下）。此外，RID 只需要两个字节长，因为它们只需要指定段内的行位置（一个段的 48K 行可以用一个短整型计算）。在每个 RID 列表的开头，段号将指定一个较长 RID（4字节或更多）的高阶位，但是相对于段的 RID 只使用两个字节。这是一种重要的前缀 RID 压缩形式，可大大的加快索引范围搜索的速度。

第二个影响是在组合谓词时节省了 I/O。在 MODEL 204 中，特定值的 B 树索引条目由许多指针组成，这些指针按段指向位图或 RID 列表片段，但只有当分端具有代表性行时才会这样。例如，在一个聚类索引的情况下，每个特定的索引值条目只有指向少数几个段的指针。现在，如果对涉及不同列索引的几个谓词进行逻辑与 AND 计算，那么我们可以以人为计算是逐段进行的。如果其中一个谓词索引没有指向位图或者 RID 列表片段的指针，那么其他谓词的索引段片段也可以被忽略。像这样的查询可能在负载中非常常见，通过忽略这些索引片段的 I/O 会对性能产生重大影响。

从某种意义上说，位图表示和 RID 列表表示法是可以互换的：两者都提供了一种方法来列出所有具有给定索引值或值范围的行。只是，当涉及的位图表示相对密集时，位图在存储使用和布尔操作效率上都比 RID 列表更加高效。实际上，只要在某些段中，给定键值的行数过于稀少，无法有效使用位图，那么位图索引就可以包含某些条目值的 RID 列表，甚至是条目中某些段的 RID 列表。在下文中，我们将假设位图索引根据需要结合位图和 RID 列表表示法，并继续将这种混合形式称为值列表索引。当我们提到索引中给定值v的位图时，我们不认为是一个通用名称：它可能是一个位图，也可能是一个 RID 列表，或者是这两种形式的逐段组合。我们打算将这种索引的使用与两种新的非传统形式的索引进行比较，我们将它称为投影索引和位切片索引。

### 2.2 投影索引 Projection Indexes

投影索引是一种简单的结构。假设 C 是表 T 中的一个列，那么 C 上的投影索引就是由 C 列值的存储序列组成，根据从表 T 中提取值的行号进行排序。如果 C 列的长度是固定的，长度为 4 字节，那么我们可以在每个 4KB 大小的磁盘页上放置1000 个 C 列的值，并对连续的列值继续这样操作，直到我们构建出投影索引。现在对于表中给定的行号 n = m(r)，我们可以访问正确的磁盘页 p 和槽位 s，可以通过一个简单的公式来检索相应的 C 值：`p = n/1000` 和 `s = n%1000`。此外，给定投影索引中某位置的 C 值，我们可以轻松地计算出行号：`n = 1000*p + s`。

如果 C 列的值是可变长度而不是固定长度，有两种选择。我们可以设置一个最大值，然后像以前一样在每个页上放置固定数量的列值，或者使用 B 树结构来通过查找行号 n 来访问列值 C。可变长度值的场景显然比固定长度的效率低一些，在接下来的内容中我们将假设 C 值是固定长度。

在必须为 Foundset 的所有行检索列值的情况下，如果 Foundset 足够密集，可能会在投影索引的同一磁盘页上找到几个列值，但是行本身较大时，会出现在几个不同的磁盘页上，这时投影索引就非常有用。例如，如果 Foundset 的密度为 1/50(没有聚类，因此密度在所有表段之间是均匀的)，并且列值的长度为 4 字节，则会发生这种情况，如上所述。那么在 4KB 的磁盘页可以容纳 1000 个值，我们预计每个投影索引页可以提取 20 个值。相反，如果检索表的行，假设行长 200 字节，那么 4KB 的页面只能容纳 20 行，我们预计每页只能读取 1 行。因此，从投影索引读取值所需的页访问次数仅为从行读取值所需的页访问次数的 1/20。Sybase IQ 产品是第一个大量使用投影索引的产品，其名称为'快速投影索引'。

需要注意的是，投影索引的定义让人联想到对表中列垂直分区的方法。对于大多数 Select 语句只检索少量列的工作负载来说，垂直分区是一种很好的策略。但是，这是一个坏主意，例如，在检索每一行的大多数列并且检索密度相对较小的情况下，即使在磁盘页上有 1000 个列值也不足以实现对列值磁盘页的重复访问。垂直分区实际上是被 TPC-D 基准所禁止的，大概是因为所选择的查询还没有被充分调优到惩罚这种策略。但是投影索引不同于垂直分区。我们假设表的行仍然以连续的形式存储(TPC-D要求)，并且投影索引是提高检索效率的辅助工具。当然，这意味着列值将存储不止一次，但实际上，所有传统索引都是以同样的方式实现列值的。

### 2.3 位切片索引 Bit-Sliced Indexes

位切片索引储存了一组 '位图 Bitmap 切片'，这些切片与投影索引中保存的数据是'正交'的。正如我们将要看到的，它们为计算 Foundsets（找到的行集）的聚合提供了一种高效的手段。我们以一个例子来说明位切片索引的定义。

例 2.2：有一个名为 `SALES` 的表，其中包含了某大型连锁店的各个店铺过去一个月内的所有销售记录。`SALES` 表其中一列为 `dollar_sales`，表示每行销售所得的美元金额。

现在将 `dollar_sales` 列解释为用 N+1 位二进制数表示的美元整数。对于 `SALES` 中的行号为 n 且 `dollar_sales` 列中的值为非空值的行，我们定义一个函数 `D(n,i)，i=0,...,N`，定义如下：
- D(n,0) = 1，如果行号 n 的 `dollar_sales` 中的第 1 位是 1
- D(n,1) = 1，如果行号 n 的 `dollar_sales` 中的第 2 位是 1
- ...
- D(n,i) = 1，如果行号 n 的 `dollar_sales` 中的第 $$2^i$$ 位是 1

对于 `dollar_sales` 列中数值为空的行号为 n 的行，我们定义 `D(n,i) = 0`。现在，对于每个值 i （i=0到N），即对于 SALES 表中的某一行，`D(n,i) > 0`，我们在 SALES 表上定义位图 $$B_i$$，这样位图 $$B_i$$ 的位 n 就被设置为 `D(n,i)`。请注意，通过要求 SALES 表中的某一行的 `D(n,i)>0`，我们可以保证不必表示 SALES 表中的任何行。

例 2.1 的定义可以推广到任何表 T 中的列 C(甚至可以是列的连接，但我们不会考虑这个问题)，其中列 C 被解释为从最小有效位（i=0）到最最大有效位（i=N）的比特序列。


## 3. 比较不同索引类型的聚合计算

在本节中，我们将给出一些算法，展示如何使用值列表索引、投影索引和位切片索引来加速 SQL 查询中聚合函数的计算。我们首先详细评估在单列上的 SUM 聚合。然后再考虑评估其他聚合函数的计算，最后评估聚合函数在多列上的计算。

### 3.1 评估在单列上的 SUM 聚合

首先，我们以一个示例来说明如何使用以下四种方法来计算 SUM 聚合函数：直接读取行、使用投影索引、使用值列表索引以及使用位切片索引。假设例 2.2 中的 SALES 表有 1 亿行，长度为 200 字节，每个 4 KB 的磁盘页只存储 20 行。如果在 `SALES` 表上执行如下 Select 语句：
```sql
SELECT SUM(dollar_sales)
FROM SALES
WHERE condition;
```
> 例 3.1

Where 子句中 `condition` 过滤 `SALES` 表生成一个 Foundset 行集合。假设 Select 语句中确定的 Foundset 包含 200 万行，并且这些行不是聚集在一小部分磁盘页中，而是均匀地分布在整个表中(后面我们还会改变这些假设)。此外我们还假设 Foundset 已经确定并由位图 $$B_f$$ 表示。最可能发生的情况是，使用几个索引就可以轻松地确定 Foundset，因此与接下来的整体评估相比，所使用的资源相对较少。

【查询计划1】：通过直接访问行计算 SUM

每个磁盘页只包含 20 行，这意味着 `SALES` 表必须总共占用 500 万个磁盘页(1亿/20)。由于 Foundset $$B_f$$ 中的 200 万行仅占 `SALES` 表所有行的 1/50，因此 Foundset 占用的磁盘页数可以估计为：
$$
5,000,000(1 - e^{-2,000,000/5,000,000}) = 1,648,400 磁盘页
$$

假设一个磁盘臂以每秒检索 100 个磁盘页，那么执行这样一系列 I/O 的时间是 16,484 秒，或者说磁盘臂的使用时间超过 4 小时。我们估计需要 25 条指令才能从每个缓冲区驻留页检索正确的行和列值(这种情况会发生 2,000,000次)，但实际上，将正确的页读入缓冲区相关的 CPU 利用率要高得多。一般认为每次磁盘页 I/O 需要几千条指令才能完成。

【查询计划2】：通过投影索引计算 SUM

我们可以使用投影索引来计算 SUM，方法是访问索引中与 Foundset 中顺序行号相对应的每个 `dollar_sales` 值；这些顺序行号将按递增顺序提供。如例 2.2 所示，我们假设 `dollar_sales` 投影索引每 4KB 的磁盘页包含 1000 个值。因此，投影索引将需要 100,000 个磁盘页，我们可以预期，当检索到 2,000,000 行 Foundset 的值时，所有这些磁盘页都将一次被访问。这意味着我们将有 100,000个磁盘页 I/O，运行时间为 1000秒(大约17分钟)。除了 I/O 之外，我们可能还需要 10 条指令来将位图序号转换为磁盘页偏移量，访问适当的值，并将其添加到 SUM 中。

【查询计划3】：通过值列表索引计算 SUM

假设我们在dollar_sales上有一个value - list索引，我们可以通过遍历索引中所有可能的值并确定每个值的行来计算Foundset的SUM(dollar_sales)，然后挖掘Foundset中每个值的行数，最后将该计数乘以该值并将其加到SUM中。在伪代码中，我们有下面的算法 3.1。(注意，算法3.1的第一个条件测试Foundset中行的所有C值是否为空，在这种情况下，算法应返回null，而不是0。)

【查询计划4】：通过位切片索引计算 SUM

假设我们在例 2.2 中定义的 `dollar_sales` 上有一个位切片索引，我们可以用算法 3.2 的伪代码计算 `SUM(dollar_sales)`。
```sql
/* 假设 C 列上有一个位切片索引 包含位图 Bi(i 从 0 到 N (N = 19))，位图 Bn 以及位图 Bnn, 如例 2.2 和定义 2.1. */
If (COUNT(Bf AND Bnn) == 0)
  Return null;
SUM = 0.00
For i = 0 to N
  SUM += 2^i * COUNT(Bi AND Bf);
Return SUM;
```
> 算法 3.2 使用位切片索引计算 SUM(C)

因此，我们可以通过执行 21 个 AND 以及 21 个 COUNT 来完成计算(在 100,000,000 位的位图上)。每个位图的长度为 12.5 MB，需要 3125 个I/O，但我们假设 $$B_f$$ 在第一次读取后可以保留在内存中。因此，我们总共需要从磁盘中读取 22 个位图，需要 22*3125 = 68,750 个I/O，比查询计划2所需数量的一半多一点。对于 CPU，我们需要对 21 对位图进行 AND 处理，这可以通过在长整数块中循环位图来完成，在 32 位机器上循环传递的总数等于：21*(100,000,000,000 /32)= 65,625,000。然后我们需要执行 21 次 COUNT，以半字单指令循环的方式完成，将需要 131,250,000 次循环。然而，所有这些执行 AND 和 COUNT 的 196,875,000 次传递都是单指令循环，因此可能比计划2的 100,000,000 次多指令循环花费的时间要少得多。

#### 3.1.1 比较算法性能

#### 3.1.2 Varying Foundset Density and Clustering

### 3.2 评估其他单列聚合函数



## 4. 评估范围谓词

请看下面的 SELECT 语句：
```sql
SELECT target-list
FROM T
WHERE C-range AND <condition>;
```
> 语句 4.1

在这里，C 是表 T 的一列，`<condition>` 是生成 Foundset 结果集 $B_f$ 的一般 Where 子句过滤条件。`C-range` 是一个范围查询谓词过滤条件，可以是 `C > c1`、`C = c1`、`C >= c1`、`C < c1`、`C <= c1` 以及 `C between c1 and c2`，其中 c1 和 c2 是一个常量。在下文中我们将展示如何根据范围查询谓词进一步过滤 Foundset 结果集 $B_f$ 来生成一个新的 Foundset 结果集 $B_F$。这样 $B_F$ 准确的包含了复合谓词 `C-range AND <condition>` 过滤的行。我们在 C 列上的不同索引做出不同的假设来完成这项工作。

【1】使用投影索引计算范围
如果 C 上有一个投影索引，可以通过访问索引中对应 $B_f$ 中行号的每个 C 列值来直接创建 $B_F$，并测试它是否在指定的范围内。

【2】使用值列表索引计算范围
在值列表索引的情况下，语句 4.1 中的 C-range 过滤使用的是大多数数据库系统产品中常见的算法。由于我们有位图功能，我们稍微做一点变化，将索引中位于指定范围内的值的所有行进行 OR 操作生成位图 $B_r$，然后与 $B_f$ 进行 AND 操作。
```sql
Br = the empty set
For each entry v in the index for C that satisfies the range specified
  Designate the set of rows with the value v as Bv
  Br = Br OR Bv
BF = Bf AND Br
```
> 算法 4.1 值列表索引的范围谓词

需要注意的是，为了更高效地执行算法 4.1，我们必须找到某种方法，保证在循环遍历范围内的值 v 时，位图 $B_r$ 始终保持在内存中。如果要查询的表 T 很大，则需要在查询优化器中进行一些预先考虑：1亿行意味着必须常驻 12.5 MB 的位图 $B_r$。

【3】使用位切片索引计算范围
令人高兴的是，位切片索引可以更高效地计算范围谓词。给定一个 Foundset 结果集 $B_f$，我们将演示如何计算行集 $B_GT$ 使的 `C > c1`, $B_GE$ 使的 `C >= c1`, $B_EQ$ 使的 `C = c1`, $B_LE$ 使的 `C <= c1`, $B_LT$ 使的 `C < c1`。
```sql
BGT = BLT = the empty set; BEQ = Bnn
For each Bit-Slice Bi for C from most to least significant
  If bit i is on in constant c1
    BLT = BLT OR (BEQ AND NOT(Bi))
    BEQ = BEQ AND Bi
  else
    BGT = BGT OR (BEQ AND Bi)
    BEQ = BEQ AND NOT(Bi)
BEQ = BEQ AND Bf;
BGT = BGT AND Bf;
BLT = BLT AND Bf;
BLE = BLT OR BEQ;
BGE = BGT OR BEQ;
```
> 算法 4.2 位切片索引的范围谓词

当然，我们可以在算法 4.2 中删除我们不需要的位图计算。例如，如果我们只需要计算 `C > c1` 或 `C >= c1`，我们不需要计算 $B_LE$ 或 $B_LT$ 的步骤。

证明 $B_EQ$、$B_GT$ 和 $B_GE$ 的计算是正确的。计算 $B_EQ$ 的方法可以准确地确定 `C = c1` 的所有行，因为它要求对于 $B_EQ$ 中的所有行，c1 中的所有 1 位都为开, 所有 0 位都是关。接下来，我们注意到 $B_GT$ 是由一组特定条件下位图的 OR 操作创建的，我们现在描述这些条件。

假设 c1 的比特表示为 $b_N、b_{N-1}...b_1,b_0$，而数据库中某行r的C的位表示为rNrN-1. r1r0。对于c1中从0到N的每一个位i，位bi关闭，如果位ri打开并且位rNrN-1、位r1ri+1都等于位bNbN-1、位bNbN-1、位bi+1，则行r将在BGT中。很明显，对于BGT中任何这样的行r, C > c1。此外，对于C > c1的任何值，必须存在某个位i，使得c1的第i位位置为off, C的第i位位置为on，并且两个值中所有更有效的位都相同。因此，4.2算法可以很好地评估BGT。u (BLT和BLE被正确评估的证明是相似的。)




### 4.1 Comparing Algorithm Performance

### 4.2 Range Predicate Using a Bit-Sliced Index with a Non-Binary Base


## 5. Evaluating OLAP-style Queries


### 5.1 Join Indexes


### 5.2 Calculating Groupset Aggregates

### 5.3 Improved Grouping Efficiency Using Segmentation and Clustering


### 5.4 Groupset Indexes

## 6. Conclusion
